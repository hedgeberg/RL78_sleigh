#########################################################################
# RL78 Core in SLEIGH
#
# Based off of the work from Hedgeberg and aerosoul94
#
# MikeM64, 2020
#########################################################################

#
# Current TODO list:
#   - Register bank selection
#

define endian=little;
define alignment=1;

define space ram        type=ram_space      size=3 wordsize=1 default;
define space stackarea  type=ram_space      size=2;
define space register   type=register_space size=1;

# General Purpose registers
define register offset=0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3];  # 8-bit-mode bank3
define register offset=0x00 size=2 [AX3   BC3   DE3   HL3  ];  #16-bit-mode bank3
define register offset=0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2];  # 8-bit-mode bank2
define register offset=0x08 size=2 [AX2   BC2   DE2   HL2  ];  #16-bit-mode bank2
define register offset=0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1];  # 8-bit-mode bank1
define register offset=0x10 size=2 [AX1   BC1   DE1   HL1  ];  #16-bit-mode bank1
define register offset=0x18 size=1 [X  A  C  B  E  D  L  H ];  # 8-bit-mode bank0
define register offset=0x18 size=2 [AX    BC    DE    HL   ];  #16-bit-mode bank0

# Special purpose registers
define register offset=0x40 size=3 [PC];
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];

# Per AVR, they put status flags in their own registers for simplicity
define register offset=0x70 size=1 [IE Z PSW_RBS1 AC PSW_RBS0 ISP1 ISP0 CY];

# For storing processor context
define register offset=0x80 size=4 contextreg;

define context contextreg
    es_prefix=(0, 0);

# Bank Selection
define register offset=0x90 size=1 [ RBS0 RBS1 RBS2 RBS3 ];

# CALL Table entries
define ram offset=0x80 size=2 [
    CALLT80 CALLT82 CALLT84 CALLT86
    CALLT88 CALLT8A CALLT8C CALLT8E

    CALLT90 CALLT92 CALLT94 CALLT96
    CALLT98 CALLT9A CALLT9C CALLT9E

    CALLTA0 CALLTA2 CALLTA4 CALLTA6
    CALLTA8 CALLTAA CALLTAC CALLTAE

    CALLTB0 CALLTB2 CALLTB4 CALLTB6
    CALLTB8 CALLTBA CALLTBC CALLTBE
];

# Implementation-specific special function registers, starting from 0xFFF00
define ram offset=0xFFF00 size=1 [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];

#########################################################################
#
# Pseudocode ops
#
#########################################################################

define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

define pcodeop divwu;
define pcodeop machu;
define pcodeop mach;

define pcodeop disable_interrupts;
define pcodeop enable_interrupts;

#########################################################################
#
# Instruction token and field definitions
#
#########################################################################

define token base (8)
    opcode = (0, 7)
    op_h = (4, 7)
    op_l = (0, 3)
    # Whether an rp (16-bit) register is the data source
    rp_source = (0, 0)
    mov1_sreg   = (7, 7)
    # The n'th bit to use for *1 instructions
    bit_op_n = (4, 6)
    # Register bank selection also uses the same bits
    # as the bitwise operators
    rbs_op_n = (4, 5)
    # Unused instructions
    clrb_unused = (2, 3)
    movw_op = (3, 3)
    call_rp = (4, 6)
    dreg_word = (1, 2)
    dreg_byte = (0, 2)
    dreg_axbc = (0, 1)
    sreg_byte = (0, 2);
attach variables [ dreg_byte sreg_byte ] [X A C B E D L H];
attach variables [ dreg_axbc ] [X A C B];
attach variables [ dreg_word ] [AX BC DE HL];
attach variables [ call_rp ] [ _ _ _ _ AX BC DE HL];
attach variables [ rbs_op_n ] [ RBS0 RBS1 RBS2 RBS3 ];

define token base2 (8)
    # Bits 2, 7 is set and Bit 3 is unset for CALLT instructions
    op2_b7       = (7, 7)
    op2_b23      = (2, 3)
    op2_callt_low = (4, 6)
    op2_callt_hi  = (0, 1)
    # NOTE: Many arithmetic instructions that act upon registers
    # alone are decoded by the upper 5 bits of the second byte
    # of the opcode. Ex. XOR 0x78 >> 3 -> 0xf
    op2_h       = (3, 7)
    # Bit arithmetic uses the nibble of the second byte
    # to determine the operation (See SHR)
    op2_l       = (0, 3)
    shift_n     = (4, 7)
    sreg2_byte  = (0, 2);
attach variables [ sreg2_byte ] [X A C B E D L H];

define token data8 (8)
    data        = (0, 7)
    uaddr8      = (0, 7)
    saddr8      = (0, 7) signed
    sfr_byte    = (0, 7)
    fixed_sfr_offset = (3, 7)
    fixed_sfr   = (0, 2)
    fixed_sfr_w   = (0, 2);
attach variables [ sfr_byte ] [
    SFR00 SFR01 SFR02 SFR03 SFR04 SFR05 SFR06 SFR07
    SFR08 SFR09 SFR0A SFR0B SFR0C SFR0D SFR0E SFR0F

    SFR10 SFR11 SFR12 SFR13 SFR14 SFR15 SFR16 SFR17
    SFR18 SFR19 SFR1A SFR1B SFR1C SFR1D SFR1E SFR1F

    SFR20 SFR21 SFR22 SFR23 SFR24 SFR25 SFR26 SFR27
    SFR28 SFR29 SFR2A SFR2B SFR2C SFR2D SFR2E SFR2F

    SFR30 SFR31 SFR32 SFR33 SFR34 SFR35 SFR36 SFR37
    SFR38 SFR39 SFR3A SFR3B SFR3C SFR3D SFR3E SFR3F

    SFR40 SFR41 SFR42 SFR43 SFR44 SFR45 SFR46 SFR47
    SFR48 SFR49 SFR4A SFR4B SFR4C SFR4D SFR4E SFR4F

    SFR50 SFR51 SFR52 SFR53 SFR54 SFR55 SFR56 SFR57
    SFR58 SFR59 SFR5A SFR5B SFR5C SFR5D SFR5E SFR5F

    SFR60 SFR61 SFR62 SFR63 SFR64 SFR65 SFR66 SFR67
    SFR68 SFR69 SFR6A SFR6B SFR6C SFR6D SFR6E SFR6F

    SFR70 SFR71 SFR72 SFR73 SFR74 SFR75 SFR76 SFR77
    SFR78 SFR79 SFR7A SFR7B SFR7C SFR7D SFR7E SFR7F

    SFR80 SFR81 SFR82 SFR83 SFR84 SFR85 SFR86 SFR87
    SFR88 SFR89 SFR8A SFR8B SFR8C SFR8D SFR8E SFR8F

    SFR90 SFR91 SFR92 SFR93 SFR94 SFR95 SFR96 SFR97
    SFR98 SFR99 SFR9A SFR9B SFR9C SFR9D SFR9E SFR9F

    SFRA0 SFRA1 SFRA2 SFRA3 SFRA4 SFRA5 SFRA6 SFRA7
    SFRA8 SFRA9 SFRAA SFRAB SFRAC SFRAD SFRAE SFRAF

    SFRB0 SFRB1 SFRB2 SFRB3 SFRB4 SFRB5 SFRB6 SFRB7
    SFRB8 SFRB9 SFRBA SFRBB SFRBC SFRBD SFRBE SFRBF

    SFRC0 SFRC1 SFRC2 SFRC3 SFRC4 SFRC5 SFRC6 SFRC7
    SFRC8 SFRC9 SFRCA SFRCB SFRCC SFRCD SFRCE SFRCF

    SFRD0 SFRD1 SFRD2 SFRD3 SFRD4 SFRD5 SFRD6 SFRD7
    SFRD8 SFRD9 SFRDA SFRDB SFRDC SFRDD SFRDE SFRDF

    SFRE0 SFRE1 SFRE2 SFRE3 SFRE4 SFRE5 SFRE6 SFRE7
    SFRE8 SFRE9 SFREA SFREB SFREC SFRED SFREE SFREF

    SFRF0 SFRF1 SFRF2 SFRF3 SFRF4 SFRF5 SFRF6 SFRF7
    SFRF8 SFRF9 SFRFA SFRFB SFRFC SFRFD SFRFE SFRFF
];
attach variables [ fixed_sfr ] [ SPL SPH PSW _ CS ES PMC MEM ];
attach variables [ fixed_sfr_w ] [ SP _ _ _ _ _ _ _ ];

define token data16 (16)
    dataw = (0, 15)
    uaddr16 = (0, 15)
    saddr16 = (0, 15) signed
    a16_sfr_offset = (3, 15)
    a16_sfr_reg = (0, 2)
    a16w_sfr_reg = (0, 2);
attach variables [ a16_sfr_reg ] [ SPL SPH PSW _ CS ES PMC MEM ];
attach variables [ a16w_sfr_reg ] [ SP _ _ _ _ _ _ _ ];

define token data24 (24)
    uaddr20 = (0, 19);

#########################################################################
#
# Instruction macros
#
#########################################################################

macro inst_xch(dst, src) {
    local tmp:1 = dst;
    dst = src;
    src = tmp;
}

macro inst_inc(dst) {
    dst = dst + 1;
    Z = (dst == 0);
    # Generate the carry if the increment generates a carry for bit 4 out of bit 3
    # Clear in all other cases
    AC = (dst == 0x8);
}

macro inst_dec(dst) {
    dst = dst - 1;
    Z = (dst == 0);
    # Generate the carry if the decrement generates a carry for bit 3 out of bit 4
    # Clear in all other cases
    AC = (dst == 0x7);
}

macro inst_movs(dst) {
    dst = X;
    Z = (X == 0);
    CY = (X == 0) | (A == 0);
}

macro inst_add(dst, src) {
    dst = dst + src;
    Z = (dst == 0);
    CY = carry(dst, src);
    AC = (dst & 0x04) < (src & 0x04);
}

macro inst_addc(dst, src) {
    dst = dst + CY;
    inst_add(dst, src);
}

macro inst_sub(dst, src) {
    dst = dst - src;
    Z = (dst == 0);
    CY = sborrow(dst, src);
    AC = (dst & 0x08) >= (src & 0x08);
}

macro inst_subc(dst, src) {
    dst = dst - CY;
    inst_sub(dst, src);
}

macro inst_and(dst, src) {
    dst = dst & src;
    Z = (dst == 0);
}

macro inst_or(dst, src) {
    dst = dst | src;
    Z = (dst == 0);
}

macro inst_xor(dst, src) {
    dst = dst ^ src;
    Z = (dst == 0);
}

macro inst_incw(dst) {
    dst = dst + 1;
}

macro inst_decw(dst) {
    dst = dst - 1;
}

macro inst_shr(dst, n) {
    CY = (dst:1 & 0x01) != 0;
    dst = dst >> n;
}

macro inst_shl(dst, n) {
    CY = (dst:1 & 0x80) != 0;
    dst = dst << n;
}

macro inst_shlw(dst, n) {
    CY = (dst:2 & 0x8000) != 0;
    dst = dst << n;
}

macro inst_sar(dst, n) {
    local msb:1 = dst & 0x80;
    CY = dst:1 & 0x01;
    dst = dst >> n;
    dst = dst & msb;
}

macro inst_sarw(dst, n) {
    local msb:2 = dst & 0x8000;
    CY = dst:1 & 0x01;
    dst = dst >> n;
    dst = dst & msb; 
}

macro inst_cmp(dst, src) {
    Z = (dst - src) == 0;
    AC = (dst & 0x08) >= (src & 0x08);
    CY = sborrow(dst, src);
}

macro inst_cmp0(dst) {
    Z = dst == 0;
    AC = 0;
    CY = 0;
}

macro inst_cmps(dst, src) {
    Z = (dst - src) == 0;
    CY = (Z != 0) | (A == 0) | (dst == 0);
    AC = (dst & 0x08) >= (src & 0x08);
}

macro inst_addw(dst, src) {
    CY = carry(dst, src);
    dst = dst + src;
    Z = (dst == 0);
    AC = 0;
}

macro inst_subw(dst, src) {
    CY = sborrow(dst, src);
    dst = dst - src;
    Z = (dst == 0);
    AC = 0;
}

macro inst_cmpw(dst, src) {
    Z = (dst - src) == 0;
    AC = 0;
    CY = sborrow(dst, src);
}

macro update_psw(data) {
    # Update PSW as expected
    PSW    = data;
    # Then split it apart into the shadow registers
    # for use during decompilation
    IE     = (data & 0x80) >> 7;
    Z      = (data & 0x40) >> 6;
    PSW_RBS1   = (data & 0x20) >> 5;
    AC     = (data & 0x10) >> 4;
    PSW_RBS0   = (data & 0x08) >> 3;
    ISP1   = (data & 0x04) >> 2;
    ISP0   = (data & 0x02) >> 1;
    CY     = (data & 0x01);
}

macro inst_rolwc(dst) {
    local msb:1 = (dst & 0x8000) != 0;
    dst = dst << 1;
    dst = dst | zext(CY);
    CY = msb;
}

macro mov1_read(dst, src, bit) {
    dst = (src & (1 << bit)) != 0;
}

macro mov1_write(dst, src, bit) {
    dst = dst | (src & (1 << bit));
}

# Destination for AND1 is always CY
macro inst_and1(src, bit) {
    local src_bit:1 = (src & (1 << bit)) >> bit;
    CY = CY & src_bit;
}

# Destination for OR1 is always CY
macro inst_or1(src, bit) {
    local src_bit:1 = (src & (1 << bit) >> bit);
    CY = CY | src_bit;
}

# Destination for XOR1 is always CY
macro inst_xor1(src, bit) {
    local src_bit:1 = (src & (1 << bit) >> bit);
    CY = CY ^ src_bit;
}

macro inst_set1(dst, bit) {
    dst = dst | (1 << bit);
}

macro inst_clr1(dst, bit) {
    dst = dst & (~dst & (0 << bit));
}

macro push_byte(src) {
    SP = SP - 1;
    *[stackarea]:1 SP = src;
    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
}

macro pop_byte(dst) {
    SP = SP + 2;
    dst = *[stackarea]:1 SP;
}

macro push_word(src) {
    SP = SP - 2;
    *[stackarea]:2 SP = src;
}

macro pop_word(dst) {
    SP = SP + 2;
    dst = *[stackarea]:2 SP;
}

macro branch(target) {
    PC = target;
    goto target;
}

macro inst_bt(src, bit, target) {
    if (src & (1 << bit)) goto target;
}

macro inst_bf(src, bit, target) {
    if (!(src & (1 << bit))) goto target;
}

macro inst_btclr(src, bit, target) {
    if (!(src & (1 << bit))) goto target;
    # Clear the bit post-branch, would be a NOP
    # if the bit was not set in the first place
    src = (~src & (0 << bit));
}

macro inst_sk(test) {
    if (test) goto inst_next;
    delayslot(1);
    goto inst_next;
}

macro es_extend(addr) {
    addr = addr | ((zext(ES) & 0xF) << 16);
}

#########################################################################
#
# Root table constructors
#
#########################################################################

# Instruction data tokens

u8: "#"data is data {
    local tmp:1 = data;
    export tmp;
}

u16: "#"dataw is dataw {
    local tmp:2 = dataw;
    export tmp;
}

saddr: loc is uaddr8 [ loc = 0xFFE00 + uaddr8; ] {
    export *:1 loc;
}

saddrp: uaddr8 is uaddr8 {
    local loc:3 = (0xFFE00 + uaddr8) & 0x0FFFFE;
    export *:2 loc;
}

addr16: "!"loc is es_prefix=0 & uaddr16 [ loc = 0xF0000 + uaddr16; ] {
    export *:1 loc;
}

addr16: a16_sfr_reg is es_prefix=0 & a16_sfr_reg & a16_sfr_offset=0x1fff {
    export a16_sfr_reg;
}

addr16: ES:"!"uaddr16 is es_prefix=1 & uaddr16 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = uaddr16;
    es_extend(loc);
    export *:1 loc;
}

addr16w: "!"uaddr16 is es_prefix=0 & uaddr16 {
    local tmp:3 = (0xF0000 + uaddr16) & 0xFFFFFE;
    export *:2 tmp;
}

addr16w: a16w_sfr_reg is es_prefix=0 & a16w_sfr_reg & a16_sfr_offset=0x1fff {
    export a16w_sfr_reg;
}

addr16w: ES:"!"uaddr16 is es_prefix=1 & uaddr16 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local tmp:3 = uaddr16;
    es_extend(tmp);
    export *:2 tmp;
}

addr20: "!!"uaddr20 is uaddr20 {
    export *:3 uaddr20;
}

sfrp: loc is sfr_byte [ loc = 0xFFF00 + sfr_byte; ] {
    export *:1 loc;
}

sfrp: fixed_sfr is fixed_sfr & fixed_sfr_offset=0x1f {
    export fixed_sfr;
}

# TODO: Doesn't mask off on even addresses without complicating the
# decompilation. Tried to calculate using the below:
# local tmp:3 = (0xFFF00 + zext(sfr_byte)) & 0xFFFFFE;
sfrpw: sfr_byte is sfr_byte {
    local tmp:3 = zext(sfr_byte);
    export *:2 tmp;
}

sfrpw: fixed_sfr_w is fixed_sfr_w & fixed_sfr_offset=0x1f {
    export fixed_sfr_w;
}

jdisp8: "$"loc is saddr8 [ loc = inst_next + saddr8; ] {
    export *:3 loc;
}

jaddr16: "!"loc is uaddr16 [ loc = 0x0000 | uaddr16; ] {
    export *:3 loc;
}

jdisp16: "$!"loc is saddr16 [ loc = inst_next + saddr16; ] {
    export *:3 loc;
}

brk_addr: loc is opcode [ loc = 0x007F7E; ] {
    export *:3 loc;
}

ret_addr: opcode is opcode {
    local tmp:3 = *[stackarea]:3 SP;
    SP = SP + 4;
    export *:3 tmp;
}

# From page 21 of the RL78 ISA manual, CALL rp uses register
# indirect addressing that uses CS along with the contents
# of the register pair.
call_reg_addr: call_rp is call_rp {
    local loc:3 = zext(call_rp);
    loc = loc | ((zext(CS) & 0x0f) << 16);
    export *:3 loc;
}

# Register Ponter tokens - [r]

AddrDE: [DE] is es_prefix=0 & DE {
    local loc:3 = 0xF0000 | zext(DE);
    export *:1 loc;
}

AddrDE: ES:[DE] is es_prefix=1 & DE & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(DE);
    es_extend(loc);
    export *:1 loc;
}

AddrDEW: [DE] is es_prefix=0 & DE {
    local loc:3 = 0xF0000 | zext(DE);
    export *:2 loc;
}

AddrDEW: ES:[DE] is es_prefix=1 & DE & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(DE);
    es_extend(loc);
    export *:2 loc;
}

AddrDEOffset: [DE+uaddr8] is es_prefix=0 & DE & uaddr8 {
    local loc:3 = 0xF0000 | (zext(DE) + uaddr8);
    export *:1 loc;
}

AddrDEOffset: ES:[DE+uaddr8] is es_prefix=1 & DE & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(DE) + uaddr8;
    es_extend(loc);
    export *:1 loc;
}

AddrDEOffsetW: [DE+uaddr8] is es_prefix=0 & DE & uaddr8 {
    local loc:3 = 0xF0000 | (zext(DE) + uaddr8);
    export *:2 loc;
}

AddrDEOffsetW: ES:[DE+uaddr8] is es_prefix=1 & DE & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ]{
    local loc:3 = zext(DE) + uaddr8;
    es_extend(loc);
    export *:2 loc;
}

AddrHL: [HL] is HL & es_prefix=0 {
    local loc:3 = 0xF0000 | zext(HL);
    export *:1 loc;
}

AddrHL: ES:[HL] is HL & es_prefix=1 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(HL);
    es_extend(loc);
    export *:1 loc;
}

AddrHLW: [HL] is es_prefix=0 & HL {
    local loc:3 = 0xF0000 | zext(HL);
    export *:2 loc;
}

AddrHLW: ES:[HL] is es_prefix=1 & HL & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(HL);
    es_extend(loc);
    export *:2 loc;
}

AddrHLOffset: [HL+uaddr8] is es_prefix=0 & HL & uaddr8 {
    local loc:3 = 0xF0000 | (zext(HL) + uaddr8);
    export *:1 loc;
}

AddrHLOffset: ES:[HL+uaddr8] is es_prefix=1 & HL & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ]{
    local loc:3 = zext(HL) + uaddr8;
    es_extend(loc);
    export *:1 loc;
}

AddrHLOffsetW: [HL+uaddr8] is es_prefix=0 & HL & uaddr8 {
    local loc:3 = 0xF0000 | (zext(HL) + uaddr8);
    export *:2 loc;
}

AddrHLOffsetW: ES:[HL+uaddr8] is es_prefix=1 & HL & uaddr8 & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(HL) + uaddr8;
    es_extend(loc);
    export *:2 loc;
}

AddrHLOffsetB: [HL+B] is es_prefix=0 & HL & B {
    local loc:3 = 0xF0000 | (zext(HL) + zext(B));
    export *:1 loc;
}

AddrHLOffsetB: ES:[HL+B] is es_prefix=1 & HL & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(HL) + zext(B);
    es_extend(loc);
    export *:1 loc;
}

AddrHLOffsetC: [HL+C] is es_prefix=0 & HL & C {
    local loc:3 = 0xF0000 | (zext(HL) + zext(C));
    export *:1 loc;
}

AddrHLOffsetC: ES:[HL+C] is es_prefix=1 & HL & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = zext(HL) + zext(C);
    es_extend(loc);
    export *:1 loc;
}

AddrWordOffsetB: uaddr16[B] is es_prefix=0 & uaddr16 & B {
    local loc:3 = 0xF0000 | (uaddr16 + zext(B));
    export *:1 loc;
}

AddrWordOffsetB: ES:uaddr16[B] is es_prefix=1 & uaddr16 & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = uaddr16 + zext(B);
    es_extend(loc);
    export *:1 loc;
}

AddrWordOffsetBW: uaddr16[B] is es_prefix=0 & uaddr16 & B {
    local loc:3 = (0xF0000 | (uaddr16 + zext(B))) & 0x0FFFFE;
    export *:2 loc;
}

AddrWordOffsetBW: ES:uaddr16[B] is es_prefix=1 & uaddr16 & B & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = (uaddr16 + zext(B)) & 0xFFFFFE;
    es_extend(loc);
    export *:2 loc;
}

AddrWordOffsetC: uaddr16[C] is es_prefix=0 & uaddr16 & C {
    local loc:3 = 0xF0000 | (uaddr16 + zext(C));
    export *:1 loc;
}

AddrWordOffsetC: ES:uaddr16[C] is es_prefix=1 & uaddr16 & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = uaddr16 + zext(C);
    es_extend(loc);
    export *:1 loc;
}

AddrWordOffsetCW: uaddr16[C] is es_prefix=0 & uaddr16 & C {
    local loc:3 = (0xF0000 | (uaddr16 + zext(C))) & 0xFFFFE;
    export *:2 loc;
}

AddrWordOffsetCW: ES:uaddr16[C] is es_prefix=1 & uaddr16 & C & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = (uaddr16 + zext(C)) & 0xFFFFFE;
    es_extend(loc);
    export *:2 loc;
}

AddrWordOffsetBC: uaddr16[BC] is es_prefix=0 & uaddr16 & BC {
    local loc:3 = 0xF0000 | (uaddr16 + zext(BC));
    export *:1 loc;
}

AddrWordOffsetBC: ES:uaddr16[BC] is es_prefix=1 & uaddr16 & BC & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = uaddr16 + zext(BC);
    es_extend(loc);
    export *:1 loc;
}

AddrWordOffsetBCW: uaddr16[BC] is es_prefix=0 & uaddr16 & BC {
    local loc:3 = (0xF0000 | (uaddr16 + zext(BC))) & 0xFFFFFE;
    export *:2 loc;
}

AddrWordOffsetBCW: ES:uaddr16[BC] is es_prefix=1 & uaddr16 & BC & ES [ es_prefix=0; globalset(inst_start, es_prefix); ] {
    local loc:3 = (uaddr16 + zext(BC)) & 0xFFFFFE;
    es_extend(loc);
    export *:2 loc;
}

AddrSPOffset: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = 0xF0000 | (zext(SP) + uaddr8);
    export *:1 loc;
}

AddrSPOffsetW: [SP+uaddr8] is SP & uaddr8 {
    local loc:3 = 0xF0000 | (zext(SP) + uaddr8);
    export *:2 loc;
}

CALLT_Entry: [ct_entry] is op2_callt_low & op2_callt_hi
    [ ct_entry = 0x80 | ((op2_callt_hi << 4) | op2_callt_low << 1); ] {
    export *:2 ct_entry;
}

#########################################################################
#
# Root table instructions
#
#########################################################################

#
# Table 1/30
#

# MOV r, #byte
:MOV dreg_byte, "#"data is op_h=0x5 & dreg_byte; data {
    dreg_byte = data;
}

# MOV r, A
:MOV dreg_byte, A is op_h=0x7 & A & dreg_byte {
    dreg_byte = A;
}

# MOV A, r
:MOV A, sreg_byte is op_h=0x6 & A & sreg_byte {
    A = sreg_byte;
}

# MOV saddr, #byte
:MOV saddr, "#"data is opcode=0xCD; saddr; data {
    saddr = data;
}

# MOV sfr, #byte
:MOV sfr_byte, "#"data is opcode=0xCE; sfr_byte; data {
    sfr_byte = data;
}

# MOV !addr16, #byte
:MOV addr16, "#"data is opcode=0xCF; addr16; data {
    addr16 = data;
}

# MOV A, saddr
:MOV A, saddr is opcode=0x8D & A; saddr {
    A = saddr;
}

# MOV saddr, A
:MOV saddr, A is opcode=0x9D & A; saddr {
    saddr = A;
}

# MOV A, sfr
:MOV A, sfrp is opcode=0x8E & A; sfrp {
    A = sfrp;
}

# MOV sfr, A
:MOV sfrp, A is opcode=0x9E & A; sfrp {
    sfrp = A;
}

# MOV A, !addr16
:MOV A, addr16 is opcode=0x8F & A; addr16 {
    A = addr16;
}

# MOV !addr16, A
:MOV addr16, A is opcode=0x9F & A; addr16 {
    addr16 = A;
}

# MOV PSW, #byte
:MOV PSW, "#"data is opcode=0x9F & PSW; opcode=0xFA; data {
    update_psw(data);
}

# MOV A, PSW
:MOV A, PSW is opcode=0x8E & A & PSW; opcode=0xFA {
    A = PSW;
}

# MOV PSW, A
:MOV PSW, A is opcode=0x9E & A & PSW; opcode=0xFA {
    update_psw(A);
}

# MOV ES, #byte
:MOV ES, "#"data is opcode=0x41 & ES; data {
    ES = data;
}

# MOV ES, saddr
:MOV ES, saddr is opcode=0x61 & ES; opcode=0xB8; saddr {
    ES = saddr;
}

# MOV A, ES
:MOV A, ES is opcode=0x8E & A & ES; opcode=0xFD {
    A = ES;
}

# MOV ES = A
:MOV ES, A is opcode=0x9E & A & ES; opcode=0xFD {
    ES = A;
}

# MOV CS, #byte
:MOV CS, "#"data is opcode=0xCE & CS; opcode=0xFC; data {
    CS = data;
}

#
# Table 2/30
#

# MOV A, CS
:MOV A, CS is opcode=0x8E & A & CS; opcode=0xFC {
    A = CS;
}

# MOV CS, A
:MOV CS, A is opcode=0x9E & A & CS; opcode=0xFC {
    CS = A;
}

# MOV A, [DE]
:MOV A, AddrDE is opcode=0x89 & A & AddrDE {
    A = AddrDE;
}

# MOV [DE], A
:MOV AddrDE, A is opcode=0x99 & A & AddrDE {
    AddrDE = A;
}

# MOV [DE+byte], #byte
:MOV AddrDEOffset, "#"data is opcode=0xCA; AddrDEOffset; data {
    AddrDEOffset = data;
}

# MOV A, [DE+byte]
:MOV A, AddrDEOffset is opcode=0x8A & A; AddrDEOffset {
    A = AddrDEOffset;
}

# MOV [DE+byte], A
:MOV AddrDEOffset, A is opcode=0x9A & A; AddrDEOffset {
    AddrDEOffset = A;
}

# MOV A, [HL]
:MOV A, AddrHL is opcode=0x8B & A & AddrHL {
    A = AddrHL;
}

# MOV [HL], A
:MOV AddrHL, A is opcode=0x9B & A & AddrHL {
    AddrHL = A;
}

# MOV [HL+byte], #byte
:MOV AddrHLOffset, u8 is opcode=0xCC; AddrHLOffset; u8 {
    AddrHLOFfset = u8;
}

# MOV A, [HL+byte]
:MOV A, AddrHLOffset is opcode=0x8C & A; AddrHLOffset {
    A = AddrHLOffset;
}

# MOV [HL+byte], A
:MOV AddrHLOffset, A is opcode=0x9C & A; AddrHLOffset {
    AddrHLOffset = A;
}

# MOV A, [HL+B]
:MOV A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xC9 & AddrHLOffsetB {
    A = AddrHLOffsetB;
}

# MOV [HL+B], A
:MOV AddrHLOffsetB, A is opcode=0x61 & A; opcode=0xD9 & AddrHLOffsetB {
    AddrHLOffsetB = A;
}

# MOV A, [HL+C]
:MOV A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xE9 & AddrHLOffsetC {
    A = AddrHLOffsetC;
}

# MOV [HL+C], A
:MOV AddrHLOffsetC, A is opcode=0x61 & A; opcode=0xF9 & AddrHLOffsetC {
    AddrHLOffsetC = A;
}

# MOV word[B], #byte
:MOV AddrWordOffsetB, u8 is opcode=0x19; AddrWordOffsetB; u8 {
    AddrWordOffsetB = u8;
}

# MOV A, word[B]
:MOV A, AddrWordOffsetB is opcode=0x09 & A; AddrWordOffsetB {
    A = AddrWordOffsetB;
}

# MOV word[B], A
:MOV AddrWordOffsetB, A is opcode=0x18 & A; AddrWordOffsetB {
    AddrWordOffsetB = A;
}

# MOV word[C], #byte
:MOV AddrWordOffsetC, u8 is opcode=0x38; AddrWordOffsetC; u8 {
    AddrWordOffsetC = u8;
}

# MOV A, word[C]
:MOV A, AddrWordOffsetC is opcode=0x29 & A; AddrWordOffsetC {
    A = AddrWordOffsetC;
}

# MOV word[C], A
:MOV AddrWordOffsetC, A is opcode=0x28 & A; AddrWordOffsetC {
    AddrWordOffsetC = A;
}

# MOV word[BC], #byte
:MOV AddrWordOffsetBC, u8 is opcode=0x39; AddrWordOffsetBC; u8 {
    AddrWordOffsetBC = u8;
}

# MOV A, word[BC]
:MOV A, AddrWordOffsetBC is opcode=0x49 & A; AddrWordOffsetBC {
    A = AddrWordOffsetBC;
}

# MOV word[BC], A
:MOV AddrWordOffsetBC, A is opcode=0x48 & A; AddrWordOffsetBC {
    AddrWordOffsetBC = A;
}

# MOV [SP+byte], #byte
:MOV AddrSPOffset, u8 is opcode=0xC8; AddrSPOffset; u8 {
    AddrSPOffset = u8;
}

# MOV A, [SP+byte]
:MOV A, AddrSPOffset is opcode=0x88 & A; AddrSPOffset {
    A = AddrSPOffset;
} 

# MOV [SP+byte], A
:MOV AddrSPOffset, A is opcode=0x98 & A; AddrSPOffset {
    AddrSPOffset = A;
}

# MOV B, saddr
:MOV B, saddr is opcode=0xE8 & B; saddr {
    B = saddr;
}

# MOV B, !addr16
:MOV B, addr16 is opcode=0xE9 & B; addr16 {
    B = addr16;
}

# MOV C, saddr
:MOV C, saddr is opcode=0xF8 & C; saddr {
    C = saddr;
}

# MOV C, !addr16
:MOV C, addr16 is opcode=0xF9 & C; addr16 {
    C = addr16;
}

# MOV X, saddr
:MOV X, saddr is opcode=0xD8 & X; saddr {
    X = saddr;
}

# MOV X, !addr16
:MOV X, addr16 is opcode=0xD9 & X; addr16 {
    X = addr16;
}

#
# Table 3/30
#

# XCH A, X
:XCH A, X is opcode=0x08 & A & X {
    inst_xch(A, X);
}

# XCH A, r
:XCH A, sreg2_byte is opcode=0x61; op2_h=0x11 & sreg2_byte & A {
    inst_xch(A, sreg2_byte);
}

# XCH A, saddr
:XCH A, saddr is opcode=0x61 & A; opcode=0xA8; saddr {
    inst_xch(A, saddr);
}

# XCH A, sfr
:XCH A, sfr_byte is opcode=0x61 & A; opcode=0xAB; sfr_byte {
    inst_xch(A, sfr_byte);
}

# XCH A, !addr16
:XCH A, addr16 is opcode=0x61 & A; opcode=0xAA; addr16 {
    inst_xch(A, addr16);
}

# XCH A, [DE]
:XCH A, AddrDE is opcode=0x61 & A; opcode=0xAE & AddrDE {
    inst_xch(A, AddrDE);
}

# XCH A, [DE+byte]
:XCH A, AddrDEOffset is opcode=0x61 & A; opcode=0xAF; AddrDEOffset {
    inst_xch(A, AddrDEOffset);
}

# XCH A, [HL]
:XCH A, AddrHL is opcode=0x61 & A; opcode=0xAC & AddrHL {
    inst_xch(A, AddrHL);
}

# XCH A, [HL+byte]
:XCH A, AddrHLOffset is opcode=0x61 & A; opcode=0xAD; AddrHLOffset {
    inst_xch(A, AddrHLOffset);
}

# XCH A, [HL+B]
:XCH A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xB9 & AddrHLOffsetB {
    inst_xch(A, AddrHLOffsetB);
}

# XCH A, [HL+C]
:XCH A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xA9 & AddrHLOffsetC {
    inst_xch(A, AddrHLOffsetC);
}

#
# Table 4/30
#

# ONEB r
:ONEB dreg_axbc is op_h=0xE & dreg_axbc {
    dreg_axbc = 1;
}

# ONEB saddr
:ONEB saddr is opcode=0xE4; saddr {
    saddr = 1; 
}

# ONEB !addr16
:ONEB addr16 is opcode=0xE5; addr16 {
    addr16 = 1;
}

# CLRB r
:CLRB dreg_axbc is op_h=0xF & dreg_axbc & clrb_unused=0  {
    dreg_axbc = 0;
}

# CLRB saddr
:CLRB saddr is opcode=0xF4; saddr {
    saddr = 0;
}

# CLRB !addr16
:CLRB addr16 is opcode=0xF5; addr16 {
    addr16 = 0;
}

# MOVS [HL+byte], X
:MOVS X, AddrHLOffset ("Check "A" if zero")is opcode=0x61 & X & A; opcode=0xCE; AddrHLOffset {
    inst_movs(AddrHLOffset);
}

# MOVW rp, #word
:MOVW dreg_word, u16 is op_h=0x3 & dreg_word; u16 {
    dreg_word = u16;
}

# MOVW saddrp, #word
:MOVW saddrp, u16 is opcode=0xC9; saddrp; u16 {
    saddrp = u16;
}

# MOVW sfr, #word
:MOVW sfrpw, u16 is opcode=0xCB; sfrpw; u16 {
    sfrpw = u16;
}

# MOVW AX, saddrp
:MOVW AX, saddrp is opcode=0xAD & AX; saddrp {
    AX = saddrp;
}

# MOVW saddrp, AX
:MOVW saddrp, AX is opcode=0xBD & AX; saddrp {
    saddrp = AX;
}

# MOVW AX, sfrp
:MOVW AX, sfrpw is opcode=0xAE & AX; sfrpw {
    AX = sfrpw;
}

# MOVW sfrp, AX
:MOVW sfrpw, AX is opcode=0xBE & AX; sfrpw {
    sfrpw = AX;
}

# MOVW AX, rp
:MOVW AX, dreg_word is op_h=0x1 & AX & dreg_word & rp_source=1 {
    AX = dreg_word;
}

# MOVW rp, AX
:MOVW dreg_word, AX is op_h=0x1 & AX & dreg_word & rp_source=0 {
    dreg_word = AX;
}

# MOVW AX, !addr16
:MOVW AX, addr16w is opcode=0xAF & AX; addr16w {
    AX = addr16w;
}

# MOVW !addr16, AX
:MOVW addr16w, AX is opcode=0xBF & AX; addr16w {
    addr16w = AX;
}

# MOVW AX, [DE]
:MOVW AX, AddrDEW is opcode=0xA9 & AX & AddrDEW {
    AX = AddrDEW;
}

# MOVW [DE], AX
:MOVW AddrDEW, AX is opcode=0xB9 & AX & AddrDEW {
    AddrDEW = AX;
}

# MOVW AX, [DE+byte]
:MOVW AX, AddrDEOffsetW is opcode=0xAA & AX; AddrDEOffsetW {
    AX = AddrDEOffsetW;
}

# MOVW [DE+byte], AX
:MOVW AddrDEOffsetW, AX is opcode=0xBA & AX; AddrDEOffsetW {
    AddrDEOffsetW = AX;
}

# MOVW AX, [HL]
:MOVW AX, AddrHLW is opcode=0xAB & AX & AddrHLW {
    AX = AddrHLW;
}

# MOVW [HL], AX
:MOVW AddrHLW, AX is opcode=0xBB & AX & AddrHLW {
    AddrHLW = AX;
}

# MOVW AX, [HL+byte]
:MOVW AX, AddrHLOffsetW is opcode=0xAC & AX; AddrHLOffsetW {
    AX = AddrHLOffsetW;
}

# MOVW [HL+byte], AX
:MOVW AddrHLOffsetW, AX is opcode=0xBC & AX; AddrHLOffsetW {
    AddrHLOffsetW = AX;
}

# MOVW AX, word[B]
:MOVW AX, AddrWordOffsetBW is opcode=0x59 & AX; AddrWordOffsetBW {
    AX = AddrWordOffsetBW;
}

#
# Table 5/30
#

# MOVW word[B], AX
:MOVW AddrWordOffsetBW, AX is opcode=0x58 & AX; AddrWordOffsetBW {
    AddrWordOffsetBW = AX;
}

# MOVW AX, word[C]
:MOVW AX, AddrWordOffsetCW is opcode=0x69 & AX; AddrWordOffsetCW {
    AX = AddrWordOffsetCW;
}

# MOVW word[C], AX
:MOVW AddrWordOffsetCW, AX is opcode=0x68 & AX; AddrWordOffsetCW {
    AddrWordOffsetCW = AX;
}

# MOVW AX, word[BC]
:MOVW AX, AddrWordOffsetBCW is opcode=0x79 & AX; AddrWordOffsetBCW {
    AX = AddrWordOffsetBCW;
}

# MOVW AX, [SP+byte]
:MOVW AX, AddrSPOffsetW is opcode=0xA8 & AX; AddrSPOffsetW {
    AX = AddrSPOffsetW;
}

# MOVW [SP+byte], AX
:MOVW AddrSPOffsetW, AX is opcode=0xB8 & AX; AddrSPOffsetW {
    AddrSPOffsetW = AX;
}

# MOVW BC, saddrp
:MOVW BC, saddrp is opcode=0xDA & BC; saddrp {
    BC = saddrp;
}

# MOVW BC, !addr16
:MOVW BC, addr16w is opcode=0xDB & BC; addr16w {
    BC = addr16w;
}

# MOVW DE, saddrp
:MOVW DE, saddrp is opcode=0xEA & DE; saddrp {
    DE = saddrp;
}

# MOVW DE, !addr16
:MOVW DE, addr16w is opcode=0xEB & DE; addr16w {
    DE = addr16w;
}

# MOVW HL, saddrp
:MOVW HL, saddrp is opcode=0xFA & HL; saddrp {
    HL = saddrp;
}

# MOVW HL, !addr16
:MOVW HL, addr16w is opcode=0xFB & HL; addr16w {
    HL = addr16w;
}

# XCHW AX, rp
:XCHW AX, dreg_word is op_h=0x3 & rp_source=1 & dreg_word & AX {
    local tmp = AX;
    AX = dreg_word;
    dreg_word = tmp;
}

# ONEW AX
:ONEW AX is opcode=0xE6 & AX {
    AX = 1;
}

# ONEW BC
:ONEW BC is opcode=0xE7 & BC {
    BC = 1;
}

# CLRW AX
:CLRW AX is opcode=0xF6 & AX {
    AX = 0;
}

# CLRW BC
:CLRW BC is opcode=0xF7 & BC {
    BC = 0;
}

#
# Table 6/30
#

# ADD A, #byte
:ADD A, u8 is opcode=0x0C & A; u8 {
    inst_add(A, u8);
}

# ADD saddr, #byte
:ADD saddr, u8 is opcode=0x0A; saddr; u8 {
    inst_add(saddr, u8);
}

# ADD A, r
:ADD A, sreg2_byte is opcode=0x61 & A; op2_h=0x01 & sreg2_byte {
    inst_add(A, sreg2_byte);
}

# ADD r, A
:ADD sreg2_byte, A is opcode=0x61 & A; op2_h=0x00 & sreg2_byte {
    inst_add(sreg2_byte, A);
}

# ADD A, saddr
:ADD A, saddr is opcode=0x0B & A; saddr {
    inst_add(A, saddr);
}

# ADD A, !addr16
:ADD A, addr16 is opcode=0x0F & A; addr16 {
    inst_add(A, addr16);
}

# ADD A, [HL]
:ADD A, AddrHL is opcode=0x0D & A & AddrHL {
    inst_add(A, AddrHL);
}

# ADD A, [HL+byte]
:ADD A, AddrHLOffset is opcode=0x0E & A; AddrHLOffset {
    inst_add(A, AddrHLOffset);
}

# ADD A, [HL+B]
:ADD A, AddrHLOffsetB is opcode=0x61 & A; opcode=0x80 & AddrHLOffsetB {
    inst_add(A, AddrHLOffsetB);
}

# ADD A, [HL+C]
:ADD A, AddrHLOffsetC is opcode=0x61 & A; opcode=0x82 & AddrHLOffsetC {
    inst_add(A, AddrHLOffsetC);
}

# ADDC A, #byte
:ADDC A, u8 is opcode=0x1C & A; u8 {
    inst_addc(A, u8);
}

# ADDC saddr, #byte
:ADDC saddr, u8 is opcode=0x1A; saddr; u8 {
    inst_addc(saddr, u8);
}

# ADDC A, r
:ADDC A, sreg2_byte is opcode=0x61 & A; op2_h=0x3 & sreg2_byte {
    inst_addc(A, sreg2_byte);
}

# ADDC r, A
:ADDC sreg2_byte, A is opcode=0x61 & A; op2_h=0x2 & sreg2_byte {
    inst_addc(A, sreg2_byte);
}

#
# Table 7/30
#

# ADDC A, saddr
:ADDC A, saddr is opcode=0x1B & A; saddr {
    inst_addc(A, saddr);
}

# ADDC A, !uint16
:ADDC A, addr16 is opcode=0x1F & A; addr16 {
    inst_addc(A, addr16);
}

# ADDC A, [HL]
:ADDC A, AddrHL is opcode=0x1D & A & AddrHL {
    inst_addc(A, AddrHL);
}

# ADDC A, [HL+byte]
:ADDC A, AddrHLOffset is opcode=0x1E & A; AddrHLOffset {
    inst_addc(A, AddrHLOffset);
}

# ADDC A, [HL+B]
:ADDC A, AddrHLOffsetB is opcode=0x61 & A; opcode=0x90 & AddrHLOffsetB {
    inst_addc(A, AddrHLOffsetB);
}

# ADDC A, [HL+C]
:ADDC A, AddrHLOffsetC is opcode=0x61 & A; opcode=0x92 & AddrHLOffsetC {
    inst_addc(A, AddrHLOffsetC);
}

# SUB A, #byte
:SUB A, u8 is opcode=0x2C & A; u8 {
    inst_sub(A, u8);
}

# SUB saddr, #byte
:SUB saddr, u8 is opcode=0x2A; saddr; u8 {
    inst_sub(saddr, u8);
}

# SUB A, r
:SUB A, sreg2_byte is opcode=0x61 & A; op2_h=0x5 & sreg2_byte {
    inst_sub(A, sreg2_byte);
}

# SUB r, A
:SUB sreg2_byte, A is opcode=0x61 & A; op2_h=0x4 & sreg2_byte {
    inst_sub(sreg2_byte, A);
}

# SUB A, saddr
:SUB A, saddr is opcode=0x2B & A; saddr {
    inst_sub(A, saddr);
}

# SUB A, !addr16
:SUB A, addr16 is opcode=0x2F & A; addr16 {
    inst_sub(A, addr16);
}

# SUB A, [HL]
:SUB A, AddrHL is opcode=0x2D & A & AddrHL {
    inst_sub(A, AddrHL);
}

# SUB A, [HL+byte]
:SUB A, AddrHLOffset is opcode=0x2E & A; AddrHLOffset {
    inst_sub(A, AddrHLOffset);
}

# SUB A, [HL+B]
:SUB A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xA0 & AddrHLOffsetB {
    inst_sub(A, AddrHLOffsetB);
}

# SUB A, [HL+C]
:SUB A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xA2 & AddrHLOffsetC {
    inst_sub(A, AddrHLOffsetC);
}

#
# Table 8/30
#

# SUBC A, #byte
:SUBC A, u8 is opcode=0x3C & A; u8 {
    inst_subc(A, u8);
}

# SUBC saddr, #byte
:SUBC saddr, u8 is opcode=0x3A; saddr; u8 {
    inst_subc(saddr, u8);
}

# SUBC A, r
:SUBC A, sreg2_byte is opcode=0x61 & A; op2_h=0x7 & sreg2_byte {
    inst_subc(A, sreg2_byte);
}

# SUBC r, A
:SUBC sreg2_byte, A is opcode=0x61 & A; op2_h=0x6 & sreg2_byte {
    inst_subc(sreg2_byte, A);
}

# SUBC A, saddr
:SUBC A, saddr is opcode=0x3B & A; saddr {
    inst_subc(A, saddr);
}

# SUBC A, !addr16
:SUBC A, addr16 is opcode=0x3F & A; addr16 {
    inst_subc(A, addr16);
}

# SUBC A, [HL]
:SUBC A, AddrHL is opcode=0x3D & A & AddrHL {
    inst_subc(A, AddrHL);
}

# SUBC A, [HL+byte]
:SUBC A, AddrHLOffset is opcode=0x3E & A; AddrHLOffset {
    inst_subc(A, AddrHLOffset);
}

# SUBC A, [HL+B]
:SUBC A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xB0 & AddrHLOffsetB {
    inst_subc(A, AddrHLOffsetB);
}

# SUBC A, [HL+C]
:SUBC A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xB2 & AddrHLOffsetC {
    inst_subc(A, AddrHLOffsetC);
}

# AND A, #byte
:AND A, u8 is opcode=0x5C & A; u8 {
    inst_and(A, u8);
}

# AND saddr, #byte
:AND saddr, u8 is opcode=0x5A; saddr; u8 {
    inst_and(saddr, u8);
}

# AND A, r
:AND A, sreg2_byte is opcode=0x61 & A; op2_h=0xB & sreg2_byte {
    inst_and(A, sreg2_byte);
}

# AND r, A
:AND sreg2_byte, A is opcode=0x61 & A; op2_h=0xA & sreg2_byte {
    inst_and(sreg2_byte, A);
}

#
# Table 9/30
#

# AND A, saddr
:AND A, saddr is opcode=0x5B & A; saddr {
    inst_and(A, saddr);
}

# AND A, !addr16
:AND A, addr16 is opcode=0x5F & A; addr16 {
    inst_and(A, addr16);
}

# AND A, [HL]
:AND A, AddrHL is opcode=0x5D & A & AddrHL {
    inst_and(A, AddrHL);
}

# AND A, [HL+byte]
:AND A, AddrHLOffset is opcode=0x5E & A; AddrHLOffset {
    inst_and(A, AddrHLOffset);
}

# AND A, [HL+B]
:AND A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xD0 & AddrHLOffsetB {
    inst_and(A, AddrHLOffsetB);
}

# AND A, [HL+C]
:AND A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xD2 & AddrHLOffsetC {
    inst_and(A, AddrHLOffsetC);
}

# OR A, #byte
:OR A, u8 is opcode=0x6C & A; u8 {
    inst_or(A, u8);
}

# OR saddr, #byte
:OR saddr, u8 is opcode=0x6A; saddr; u8 {
    inst_or(saddr, u8);
}

# OR A, r
:OR A, sreg2_byte is opcode=0x61 & A; op2_h=0xD & sreg2_byte {
    inst_or(A, sreg2_byte);
}

# OR r, A
:OR sreg2_byte, A is opcode=0x61 & A; op2_h=0xC & sreg2_byte {
    inst_or(sreg2_byte, A);
}

# OR A, saddr
:OR A, saddr is opcode=0x6B & A; saddr {
    inst_or(A, saddr);
}

# OR A, !addr16
:OR A, addr16 is opcode=0x6F & A; addr16 {
    inst_or(A, addr16);
}

# OR A, [HL]
:OR A, AddrHL is opcode=0x6D & A & AddrHL {
    inst_or(A, AddrHL);
}

# OR A, [HL+byte]
:OR A, AddrHLOffset is opcode=0x6E & A; AddrHLOffset {
    inst_or(A, AddrHLOffset);
}

# OR A, [HL+B]
:OR A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xE0 & AddrHLOffsetB {
    inst_or(A, AddrHLOffsetB);
}

# OR A, [HL+C]
:OR A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xE2 & AddrHLOffsetC {
    inst_or(A, AddrHLOffsetC);
}

#
# Table 10/30
#

# XOR A, #byte
:XOR A, u8 is opcode=0x7C & A; u8 {
    inst_xor(A, u8);
}

# XOR saddr, #byte
:XOR saddr, u8 is opcode=0x7A; saddr; u8 {
    inst_xor(saddr, u8);
}

# XOR A, r
:XOR A, sreg2_byte is opcode=0x61 & A; op2_h=0xf & sreg2_byte {
    inst_xor(A, sreg2_byte);
}

# XOR r, A
:XOR sreg2_byte, A is opcode=0x61 & A; op2_h=0xe & sreg2_byte {
    inst_xor(sreg2_byte, A);
}

# XOR A, saddr
:XOR A, saddr is opcode=0x7B & A; saddr {
    inst_xor(A, saddr);
}

# XOR A, !addr16
:XOR A, addr16 is opcode=0x7f & A; addr16 {
    inst_xor(A, addr16);
}

# XOR A, [HL]
:XOR A, AddrHL is opcode=0x7D & A & AddrHL {
    inst_xor(A, AddrHL);
}

# XOR A, [HL+byte]
:XOR A, AddrHLOffset is opcode=0x7E & A; AddrHLOffset {
    inst_xor(A, AddrHLOffset);
}

# XOR A, [HL+B]
:XOR A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xF0 & AddrHLOffsetB {
    inst_xor(A, AddrHLOffsetB);
}

# XOR A, [HL+C]
:XOR A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xF2 & AddrHLOffsetC {
    inst_xor(A, AddrHLOffsetC);
}

# CMP A, #byte
:CMP A, u8 is opcode=0x4C & A; u8 {
    inst_cmp(A, u8);
}

# CMP saddr, #byte
:CMP saddr, u8 is opcode=0x4A; saddr; u8 {
    inst_cmp(saddr, u8);
}

# NOTE: Similar to XOR above, CMP can be simplified by looking
# at the 5 upper bits of the second byte of the instruction.
# 0x48 -> 0x9

# CMP A, r
:CMP A, sreg2_byte is opcode=0x61 & A; op2_h=0x9 & sreg2_byte {
    inst_cmp(A, sreg2_byte);
}

# CMP r, A
:CMP sreg2_byte, A is opcode=0x61 & A; op2_h=0x8 & sreg2_byte {
    inst_cmp(sreg2_byte, A);
}

#
# Table 11/30
#

# CMP A, saddr
:CMP A, saddr is opcode=0x4B & A; saddr {
    inst_cmp(A, saddr);
}

# CMP A, !addr16
:CMP A, addr16 is opcode=0x4F & A; addr16 {
    inst_cmp(A, addr16);
}

# CMP A, [HL]
:CMP A, AddrHL is opcode=0x4D & A & AddrHL {
    inst_cmp(A, AddrHL);
}

# CMP A, [HL+byte]
:CMP A, AddrHLOffset is opcode=0x4E & A; AddrHLOffset {
    inst_cmp(A, AddrHLOffset);
}

# CMP A, [HL+B]
:CMP A, AddrHLOffsetB is opcode=0x61 & A; opcode=0xC0 & AddrHLOffsetB {
    inst_cmp(A, AddrHLOffsetB);
}

# CMP A, [HL+C]
:CMP A, AddrHLOffsetC is opcode=0x61 & A; opcode=0xC2 & AddrHLOffsetC {
    inst_cmp(A, AddrHLOffsetC);
}

# CMP !addr16, #byte
:CMP addr16, u8 is opcode=0x40; addr16; u8 {
    inst_cmp(addr16, u8);
}

# CMP0, r
:CMP0 dreg_axbc is op_h=0xD & dreg_axbc {
    inst_cmp0(dreg_axbc);
}

# CMP0 saddr
:CMP0 saddr is opcode=0xD4; saddr {
    inst_cmp0(saddr);
}

# CMP0 !addr16
:CMP0 addr16 is opcode=0xD5; addr16 {
    inst_cmp0(addr16);
}

# CMPS X, [HL+byte]
:CMPS X, AddrHLOffset is opcode=0x61 & X; opcode=0xDE; AddrHLOffset {
    inst_cmps(X, AddrHLOffset);
}

# ADDW AX, #word
:ADDW AX, u16 is opcode=0x04 & AX; u16 {
    inst_addw(AX, u16);
}

# ADDW AX, rp
:ADDW AX, dreg_word is op_h=0x0 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_addw(AX, dreg_word);
}

# ADDW AX, saddrp
:ADDW AX, saddrp is opcode=0x06 & AX; saddrp {
    inst_addw(AX, saddrp);
}

# ADDW AX, !addr16
:ADDW AX, addr16w is opcode=0x02 & AX; addr16w {
    inst_addw(AX, addr16w);
}

# ADDW AX, [HL+byte]
:ADDW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x09; AddrHLOffsetW {
    inst_addw(AX, AddrHLOffsetW);
}

# SUBW AX, #word
:SUBW AX, u16 is opcode=0x24 & AX; u16 {
    inst_subw(AX, u16);
}

# SUBW AX, rp
:SUBW AX, dreg_word is op_h=0x2 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_subw(AX, dreg_word);
}

# SUBW AX, saddrp
:SUBW AX, saddrp is opcode=0x26 & AX; saddrp {
    inst_subw(AX, saddrp);
}

# SUBW AX, !addr16
:SUBW AX, addr16w is opcode=0x22 & AX; addr16w {
    inst_subw(AX, addr16w);
}

# SUBW AX, [HL+byte]
:SUBW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x29; AddrHLOffsetW {
    inst_subw(AX, AddrHLOffsetW);
}

#
# Table 12/30
#

# CMPW AX, #word
:CMPW AX, u16 is opcode=0x44 & AX; u16 {
    inst_cmpw(AX, u16);
}

# CMPW AX, rp
:CMPW AX, dreg_word is op_h=0x4 & AX & rp_source=1 & movw_op=0 & dreg_word {
    inst_cmpw(AX, dreg_word);
}

# CMPW AX, saddrp
:CMPW AX, saddrp is opcode=0x46 & AX; saddrp {
    inst_cmpw(AX, saddrp);
}

# CMPW AX, !addr16
:CMPW AX, addr16w is opcode=0x42 & AX; addr16w {
    inst_cmpw(AX, addr16w);
}

# CMPW AX, [HL+byte]
:CMPW AX, AddrHLOffsetW is opcode=0x61 & AX; opcode=0x49; AddrHLOffsetW {
    inst_cmpw(AX, AddrHLOffsetW);
}

# MULU X
:MULU X (AX"="A"*X") is opcode=0xD6 & AX & X & A {
    local aw:2 = zext(A:1);
    local xw:2 = zext(X:1);
    AX = aw * xw;
}

# MULHU
:MULHU ("AXBC="AX"*"BC) is opcode=0xCE; opcode=0xFB; opcode=0x01 & AX & BC {
    local axdw:4 = zext(AX:2);
    local bcdw:4 = zext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# MULH
:MULH ("AXBC="AX"*"BC) is opcode=0xCE; opcode=0xFB; opcode=0x02 & AX & BC {
    local axdw:4 = sext(AX:2);
    local bcdw:4 = sext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2; 
}

# DIVHU
:DIVHU ("AXDE="AX"/"DE) is opcode=0xCE; opcode=0xFB; opcode=0x03 & AX & DE {
    local axdw:4 = zext(AX:2);
    local dedw:4 = zext(DE:2);

    # Doesn't handle the case where DE is 0
    local div:4 = axdw / dedw;
    local rem:4 = axdw % dedw;

    dedw = div & 0xFFFF;
    axdw = rem & 0xFFFF;

    DE = dedw:2;
    AX = axdw:2;
}

# DIVWU
:DIVWU is opcode=0xCE; opcode=0xFB; opcode=0x04 { divwu(); }

# MACHU
:MACHU is opcode=0xCE; opcode=0xFB; opcode=0x05 { machu(); }

# MACH
:MACH is opcode=0xCE; opcode=0xFB; opcode=0x06 { mach(); }

# INC r
:INC dreg_byte is op_h=0x8 & dreg_byte {
    inst_inc(dreg_byte);
}

# INC saddr
:INC saddr is opcode=0xA4; saddr {
    inst_inc(saddr);
}

# INC !addr16
:INC addr16 is opcode=0xA0; addr16 {
    inst_inc(addr16);
}

# INC [HL+byte]
:INC AddrHLOffset is opcode=0x61; opcode=0x59; AddrHLOffset {
    inst_inc(AddrHLOffset);
}

# DEC r
:DEC dreg_byte is op_h=0x9 & dreg_byte {
    inst_dec(dreg_byte);
}

# DEC saddr
:DEC saddr is opcode=0xB4; saddr {
    inst_dec(saddr);
}

# DEC !addr16
:DEC addr16 is opcode=0xB0; addr16 {
    inst_dec(addr16);
}

# DEC [HL+byte]
:DEC AddrHLOffset is opcode=0x61; opcode=0x69; AddrHLOffset {
    inst_dec(AddrHLOffset);
}

#
# Table 13
#

# INCW rp
:INCW dreg_word is op_h=0xA & dreg_word {
    inst_incw(dreg_word);
}

# INCW saddrp
:INCW saddrp is opcode=0xA6; saddrp {
    inst_incw(saddrp);
}

# INCW !addr16
:INCW addr16w is opcode=0xA2; addr16w {
    inst_incw(addr16w);
}

# INCW [HL+byte]
:INCW AddrHLOffsetW is opcode=0x61; opcode=0x79; AddrHLOffsetW {
    inst_incw(AddrHLOffsetW);
}

# DECW rp
:DECW dreg_word is op_h=0xB & dreg_word {
    inst_decw(dreg_word);
}

# DECW saddrp
:DECW saddrp is opcode=0xB6; saddrp {
    inst_decw(saddrp);
}

# DECW !addr16
:DECW addr16w is opcode=0xB2; addr16w {
    inst_decw(addr16w);
}

# DECW [HL+byte]
:DECW AddrHLOffset is opcode=0x61; opcode=0x89; AddrHLOffset {
    inst_decw(AddrHLOffset);
}

# SHR A, n
:SHR A, shift_n is opcode=0x31 & A; op2_l=0xA & shift_n {
    inst_shr(A, shift_n);
}

# SHRW AX, n
:SHRW AX, shift_n is opcode=0x31 & AX; op2_l=0xE & shift_n {
    inst_shr(AX, shift_n);
}

#
# Table 14/30
#

# SHL A, n
:SHL A, shift_n is opcode=0x31 & A; op2_l=0x9 & shift_n {
    inst_shl(A, shift_n);
}

# SHL B, n
:SHL B, shift_n is opcode=0x31 & B; op2_l=0x8 & shift_n {
    inst_shl(B, shift_n);
}

# SHL C, n
:SHL C, shift_n is opcode=0x31 & C; op2_l=0x7 & shift_n {
    inst_shl(C, shift_n);
}

# SHLW AX, n
:SHLW AX, shift_n is opcode=0x31 & AX; op2_l=0xD & shift_n {
    inst_shlw(AX, shift_n);
}

# SHLW BC, n
:SHLW BC, shift_n is opcode=0x31 & BC; op2_l=0xC & shift_n {
    inst_shlw(BC, shift_n);
}

#
# Table 15/30
#

# SAR A, n
:SAR A, shift_n is opcode=0x31 & A; op2_l=0xB & shift_n {
    inst_sar(A, shift_n);
}

# SARW AX, n
:SARW AX, shift_n is opcode=0x31 & AX; op2_l=0xF & shift_n {
    inst_sarw(AX, shift_n);
}

# ROR A, 1
:ROR A, 1 is opcode=0x61 & A; opcode=0xDB {
    local lsb:1 = A & 0x1;
    CY = (lsb != 0);
    A = A >> 1;
    A = A & (CY << 7);
}

# ROL A, 1
:ROL A, 1 is opcode=0x61 & A; opcode=0xEB {
    local msb:1 = A & 0x80;
    CY = (msb != 0);
    A = A << 1;
    A = A | CY;
}

# RORC A, 1
:RORC A, 1 is opcode=0x61 & A; opcode=0xFB {
    local lsb:1 = A & 1;
    A = A >> 1;
    A = (CY << 7);
    CY = lsb;
}

# ROLC A, 1
:ROLC A, 1 is opcode=0x61 & A; opcode=0xDC {
    local msb:1 = (A & 0x80) != 0;
    A = A << 1;
    A = A | CY;
    CY = msb;
}

# ROLWC AX, 1
:ROLWC AX, 1 is opcode=0x61 & AX; opcode=0xEE {
    inst_rolwc(AX);
}

# ROLWC BC, 1
:ROLWC BC, 1 is opcode=0x61 & BC; opcode=0xBC {
    inst_rolwc(BC);
}

# MOV1 CY, saddr.n
:MOV1 CY, saddr"."bit_op_n is opcode=0x71 & CY; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr {
    mov1_read(CY, saddr, bit_op_n);
}

#
# Table 16/30
#

# MOV1 CY, sfr.n
:MOV1 CY, sfrp"."bit_op_n is opcode=0x71 & CY; op_l=0xC & bit_op_n & mov1_sreg=0; sfrp {
    mov1_read(CY, sfrp, bit_op_n);
}

# MOV1 CY, A.n
:MOV1 CY, A"."bit_op_n is opcode=0x71 & CY & A; op_l=0xC & bit_op_n & mov1_sreg=1 {
    mov1_read(CY, A, bit_op_n);
}

# MOV1 CY, PSW.n
:MOV1 CY, PSW"."bit_op_n is opcode=0x71 & CY & PSW; op_l=0xC & bit_op_n; opcode=0xFA {
    mov1_read(CY, PSW, bit_op_n);
}

# MOV1 CY, [HL].0
:MOV1 CY, AddrHL"."bit_op_n is opcode=0x71 & CY & AddrHL; op_l=0x4 & bit_op_n & mov1_sreg=1 {
    mov1_read(CY, AddrHL, bit_op_n);
}

# MOV1 saddr.n, CY
:MOV1 saddr"."bit_op_n, CY is opcode=0x71 & CY; op_l=0x1 & bit_op_n & mov1_sreg=0; saddr {
    mov1_write(saddr, CY, bit_op_n);
}

#
# Table 17/30
#

# MOV1 sfr.n, CY
:MOV1 sfrp"."bit_op_n, CY is opcode=0x71 & CY; op_l=0x9 & bit_op_n & mov1_sreg=0; sfrp {
    mov1_write(sfrp, CY, bit_op_n);
}

# MOV1 A.n, CY
:MOV1 A"."bit_op_n & 0x7, CY is opcode=0x71 & CY & A; op_l=0x9 & bit_op_n & mov1_sreg=1 {
    mov1_write(A, CY, bit_op_n);
}

# MOV1 PSW.n, CY
:MOV1 PSW"."bit_op_n, CY is opcode=0x71 & CY & PSW; op_l=0x9 & bit_op_n & mov1_sreg=0; opcode=0xFA {
    mov1_write(PSW, CY, bit_op_n);
}

# MOV1 [HL].n, CY
:MOV1 AddrHL"."bit_op_n, CY is opcode=0x71 & CY & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1 {
    mov1_write(AddrHL, CY, bit_op_n);
}

#
# Table 18/30
#

# AND1 CY, saddr.n
:AND1 CY, saddr"."bit_op_n is opcode=0x71 & CY; op_l=0x5 & bit_op_n & mov1_sreg=0; saddr {
    inst_and1(saddr, bit_op_n);
}

# AND1 CY, sfr.n
:AND1 CY, sfrp"."bit_op_n is opcode=0x71 & CY; op_l=0xD & bit_op_n & mov1_sreg=0; sfrp {
    inst_and1(sfrp, bit_op_n);
}

# AND1 CY, A.n
:AND1 CY, A"."bit_op_n is opcode=0x71 & CY & A; op_l=0xD & bit_op_n & mov1_sreg=1 {
    inst_and1(A, bit_op_n);
}

# AND1 CY, PSW.n
:AND1 CY, PSW"."bit_op_n is opcode=0x71 & CY & PSW; op_l=0xD & bit_op_n & mov1_sreg=0; opcode=0xFA {
    inst_and1(PSW, bit_op_n);
}

#
# Table 19/30
#

# AND1 CY, [HL].n
:AND1 CY, AddrHL"."bit_op_n is opcode=0x71 & CY & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1 {
    inst_and1(AddrHL, bit_op_n);
}

# OR1 CY, saddr.n
:OR1 CY, saddr"."bit_op_n is opcode=0x71 & CY; op_l=0x6 & bit_op_n & mov1_sreg=0; saddr {
    inst_or1(saddr, bit_op_n);
}

# OR1 CY, sfr.n
:OR1 CY, sfrp"."bit_op_n is opcode=0x71 & CY; op_l=0xE & bit_op_n & mov1_sreg=0; sfrp {
    inst_or1(sfrp, bit_op_n);
}

# OR1 CY, A.n
:OR1 CY, A"."bit_op_n is opcode=0x71 & CY & A; op_l=0xE & bit_op_n & mov1_sreg=1 {
    inst_or1(A, bit_op_n);
}

#
# Table 20/30
#

# OR1 CY, PSW.n
:OR1 CY, PSW"."bit_op_n is opcode=0x71 & CY & PSW; op_l=0xE & bit_op_n & mov1_sreg=0; opcode=0xFA {
    inst_or1(PSW, bit_op_n);
}

# OR1 CY, [HL].n
:OR1 CY, AddrHL"."bit_op_n is opcode=0x71 & CY & AddrHL; op_l=0x6 & bit_op_n & mov1_sreg=1 {
    inst_or1(AddrHL, bit_op_n);
}

# XOR1 CY, saddr.n
:XOR1 CY, saddr"."bit_op_n is opcode=0x71 & CY; op_l=0x7 & bit_op_n & mov1_sreg=0; saddr {
    inst_xor1(saddr, bit_op_n);
}

# XOR1 CY, sfr.n
:XOR1 CY, sfrp"."bit_op_n is opcode=0x71 & CY; op_l=0xF & bit_op_n & mov1_sreg=0; sfrp {
    inst_xor(sfrp, bit_op_n);
}

#
# Table 21/30
#

# XOR1 CY, A.n
:XOR1 CY, A"."bit_op_n is opcode=0x71 & CY & A; op_l=0xF & bit_op_n & mov1_sreg=1 {
    inst_xor(A, bit_op_n);
}

# XOR1 CY, PSW.n
:XOR1 CY, PSW"."bit_op_n is opcode=0x71 & CY & PSW; op_l=0xF & bit_op_n & mov1_sreg=0; opcode=0xFA {
    inst_xor(PSW, bit_op_n);
}

# XOR1 CY, [HL].n
:XOR1 CY, AddrHL"."bit_op_n is opcode=0x71 & CY & AddrHL; op_l=0x7 & bit_op_n & mov1_sreg=1 {
    inst_xor(PSW, bit_op_n);
}

# SET1 saddr.n
:SET1 saddr"."bit_op_n is opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr {
    inst_set1(saddr, bit_op_n);
}

#
# Table 22/30
#

# SET1 sfr.n
:SET1 sfrp"."bit_op_n is opcode=0x71; op_l=0xA & bit_op_n & mov1_sreg=0; sfrp {
    inst_set1(sfrp, bit_op_n);
}

# SET1 A.n
:SET1 A"."bit_op_n is opcode=0x71 & A; op_l=0xA & bit_op_n & mov1_sreg=1 {
    inst_set1(A, bit_op_n);
}

# SET1 !addr16.n
:SET1 addr16"."bit_op_n is opcode=0x71; op_l=0 & bit_op_n & mov1_sreg=0; addr16 {
    inst_set1(addr16, bit_op_n);
}

# SET1 PSW.n
:SET1 PSW"."bit_op_n is opcode=0x71 & PSW; op_l=0xA & bit_op_n & mov1_sreg=0; opcode=0xFA {
    inst_set1(PSW, bit_op_n);
    update_psw(PSW);
}

# SET1 [HL].n
:SET1 AddrHL"."bit_op_n is opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=1 & AddrHL {
    inst_set1(AddrHL, bit_op_n);
}

#
# Table 23/30
#

# CLR1 saddr.n
:CLR1 saddr"."bit_op_n is opcode=0x71; op_l=0x3 & bit_op_n & mov1_sreg=0; saddr {
    inst_clr1(saddr, bit_op_n);
}

# CLR1 sfr.n
:CLR1 sfrp"."bit_op_n is opcode=0x71; op_l=0xB & bit_op_n & mov1_sreg=0; sfrp {
    inst_clr1(sfrp, bit_op_n);
}

# CLR1 A.n
:CLR1 A"."bit_op_n is opcode=0x71 & A; op_l=0xB & bit_op_n & mov1_sreg=1 {
    inst_clr1(A, bit_op_n);
}

#
# Table 24/30
#

# CLR1 !addr16.n
:CLR1 addr16"."bit_op_n is opcode=0x71; op_l=0x8 & bit_op_n & mov1_sreg=0; addr16 {
    inst_clr1(addr16, bit_op_n);
}

# CLR1 PSW.n
:CLR1 PSW"."bit_op_n is opcode=0x71 & PSW; op_l=0xB & bit_op_n & mov1_sreg=0; opcode=0xFA {
    inst_clr1(PSW, bit_op_n);
    update_psw(PSW);
}

# CLR1 [HL].n
:CLR1 AddrHL"."bit_op_n is opcode=0x71 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1 {
    inst_clr1(AddrHL, bit_op_n);
}

# SET1 CY
:SET1 CY is opcode=0x71 & CY; opcode=0x80 {
    inst_set1(CY, 0);
}

# CLR1 CY
:CLR1 CY is opcode=0x71 & CY; opcode=0x88 {
    inst_clr1(CY, 0);
}

# NOT1 CY
:NOT1 CY is opcode=0x71 & CY; opcode=0xC0 {
    CY = ~CY & 0x1;
}

#
# Table 25/30
#

#
# TODO: Don't display PC as part of the disassembly,
# but removing it from the expression before "is opcode"
# means it can't be used for calling.
#

# CALL rp
:CALL call_reg_addr is opcode=0x61; call_reg_addr & op_l=0xA & mov1_sreg=1 {
    local ret_pc:3 = inst_next;

    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
    SP = SP - 3;
    *[stackarea]:3 SP = ret_pc;

    call call_reg_addr;
}

# CALL $!addr20
:CALL jdisp16 is opcode=0xFE; jdisp16 {
    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
    SP = SP - 3;
    *[stackarea]:3 SP = inst_next;

    call jdisp16;
}

# CALL !addr16
:CALL jaddr16 is opcode=0xFD; jaddr16 {
    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
    SP = SP - 3;
    *[stackarea]:3 SP = inst_next;

    call jaddr16;
}

# CALL !!addr20
:CALL addr20 is opcode=0xFC; addr20 {
    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
    SP = SP - 3;
    *[stackarea]:3 SP = inst_next;

    call addr20;
}

# CALLT [CALLT]
:CALLT CALLT_Entry is opcode=0x61; CALLT_Entry & op2_callt_hi & op2_callt_low & op2_b7=1 & op2_b23=0x1 {
    SP = SP - 1;
    *[stackarea]:1 SP = 0x00:1;
    SP = SP - 3;
    *[stackarea]:3 SP = inst_next;

    call CALLT_Entry;
} 

# BRK
:BRK is opcode=0x61; opcode=0xCC & brk_addr {
    SP = SP - 1;
    *[stackarea]:1 SP = PSW;
    SP = SP - 3;
    *[stackarea]:3 SP = inst_next;

    IE = 0;
    PSW = PSW & 0x7f;
    update_psw(PSW);

    call brk_addr;
}

# RET
:RET is opcode=0xD7 & ret_addr {
    return [ret_addr];
}

# RETI
:RETI (PC) is opcode=0x61; opcode=0xFC & PC {
    PC = *[stackarea]:3 SP;
    SP = SP + 3;
    update_psw(*[stackarea]:1 SP);
    SP = SP + 1;

    return [PC];
}

# RETB
:RETB (PC) is opcode=0x61; opcode=0xEC & PC {
    PC = *[stackarea]:3 SP;
    SP = SP + 3;
    update_psw(*[stackarea]:1 SP);
    SP = SP + 1;

    return [PC];
}

#
# Table 26/30
#

# PUSH PSW
:PUSH PSW is opcode=0x61 & PSW; opcode=0xDD {
    push_byte(PSW);
}

# PUSH rp
:PUSH dreg_word is op_h=0xC & dreg_word & rp_source=1 {
    push_word(dreg_word);
}

# POP PSW
:POP PSW is opcode=0x61 & PSW; opcode=0xCD {
    pop_byte(PSW);
}

# POP rp
:POP dreg_word is op_h=0xC & dreg_word & rp_source=0 {
    pop_word(dreg_word);
}

# MOVW SP, #word
:MOVW SP, u16 is opcode=0xCB & SP; opcode=0xF8; u16 {
    SP = u16;
}

# MOVW SP, AX
:MOVW SP, AX is opcode=0xBE & SP & AX; opcode=0xF8 {
    SP = AX;
}

# MOVW AX, SP
:MOVW AX, SP is opcode=0xAE & SP & AX; opcode=0xF8 {
    AX = SP;
}

# The following show an additional addr16 on the opcode in
# the ISA documentation. This looks like it may be a documentation
# error as they're all register operands.
# They're also commented out as they conflict with other MOVW instructions... See MOVW BC, !addr16 for example.

# MOVW BC, SP
#:MOVW BC, SP is opcode=0xDB & BC & SP {
#    BC = SP;
#}

# MOVW DE, SP
#:MOVW DE, SP is opcode=0xEB & DE & SP {
#    DE = SP;
#}

# MOVW HL, SP
#:MOVW HL, SP is opcode=0xFB & HL & SP {
#    HL = SP;
#}

# ADDW SP, #byte
:ADDW SP, u8 is opcode=0x10 & SP; u8 {
    SP = SP + zext(u8);
}

# SUBW SP, #byte
:SUBW SP, u8 is opcode=0x20 & SP; u8 {
    SP = SP - zext(u8);
}

# BR AX
:BR AX is opcode=0x61 & AX; opcode=0xCB {
    branch(zext(AX));
}

# BR $addr20
:BR jdisp8 is opcode=0xEF; jdisp8 {
    branch(jdisp8);
}

# BR $!addr20
:BR jdisp16 is opcode=0xEE; jdisp16 {
    branch(jdisp16);
}

# BR !addr16
:BR jaddr16 is opcode=0xED; jaddr16 {
    branch(jaddr16);
}

# BR !!addr20
:BR addr20 is opcode=0xEC; addr20 {
    branch(addr20);
}

# BC $addr20
# P-code doesn't allow for conditional register updates
# Only a conditional goto
:BC jdisp8 is opcode=0xDC; jdisp8 {
    if (CY) goto jdisp8;
}

# BNC $addr20
:BNC jdisp8 is opcode=0xDE; jdisp8 {
    if (!CY) goto jdisp8;
}

# BZ $addr20
:BZ jdisp8 is opcode=0xDD; jdisp8 {
    if (Z) goto jdisp8;
}

# BNZ $addr20
:BNZ jdisp8 is opcode=0xDF; jdisp8 {
    if (!Z) goto jdisp8;
}

# BH $addr20
:BH jdisp8 is opcode=0x61; opcode=0xC3; jdisp8 {
    if (!(Z | CY)) goto jdisp8;
}

# BNH $addr20
:BNH jdisp8 is opcode=0x61; opcode=0xD3; jdisp8 {
    if (Z | CY) goto jdisp8;
}

# BT saddr.n, $addr20
:BT saddr"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    inst_bt(saddr, bit_op_n, jdisp8);
}

# BT sfr.n, $addr20
:BT sfrp"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    inst_bt(sfrp, bit_op_n, jdisp8);
}

#
# Table 27/30
#

# BT A.n, $addr20
:BT A"."bit_op_n, jdisp8 is opcode=0x31 & A; op_l=0x3 & bit_op_n & mov1_sreg=0; jdisp8 {
    inst_bt(A, bit_op_n, jdisp8);
}

# BT PSW.n, $addr20
:BT PSW"."bit_op_n, jdisp8 is opcode=0x31 & PSW; op_l=0x2 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    inst_bt(PSW, bit_op_n, jdisp8);
}

# BT [HL].n, $addr20
:BT AddrHL"."bit_op_n, jdisp8 is opcode=0x31 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1; jdisp8 {
    inst_bt(AddrHL, bit_op_n, jdisp8);
}

# BF saddr.n, $addr20
:BF saddr"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    inst_bf(saddr, bit_op_n, jdisp8);
}

#
# Table 28/30
#

# BF sfr.n, $addr20
:BF sfrp"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    inst_bf(sfrp, bit_op_n, jdisp8);
}

# BF A.n, $addr20
:BF A"."bit_op_n, jdisp8 is opcode=0x31 & A; op_l=0x5 & bit_op_n & mov1_sreg=0; jdisp8 {
    inst_bf(A, bit_op_n, jdisp8);
}

# BF PSW.n, $addr20
:BF PSW"."bit_op_n, jdisp8 is opcode=0x31 & PSW; op_l=0x4 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    inst_bf(PSW, bit_op_n, jdisp8);
}

# BF [HL].n, $addr20
:BF AddrHL"."bit_op_n, jdisp8 is opcode=0x31 & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1; jdisp8 {
    inst_bf(AddrHL, bit_op_n, jdisp8);
}

#
# Table 29/30
#

# BTCLR saddr.n, $addr20
:BTCLR saddr"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    inst_btclr(saddr, bit_op_n, jdisp8);
}

# BTCLR sfr.n, $addr20
:BTCLR sfrp"."bit_op_n, jdisp8 is opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    inst_btclr(sfrp, bit_op_n, jdisp8);
}

# BTCRL A.n, $addr20
:BTCLR A"."bit_op_n, jdisp8 is opcode=0x31 & A; op_l=0x1 & bit_op_n & mov1_sreg=0; jdisp8 {
    inst_btclr(A, bit_op_n, jdisp8);
}

# BTCLR PSW.n, $addr20
:BTCLR PSW"."bit_op_n, jdisp8 is opcode=0x31 & PSW; op_l=0x0 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    inst_btclr(PSW, bit_op_n, jdisp8);
    update_psw(PSW);
}

# BTCRL [HL].n, $addr20
:BTCLR AddrHL"."bit_op_n, jdisp8 is opcode=0x31 & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1; jdisp8 {
    inst_btclr(AddrHL, bit_op_n, jdisp8);
}

#
# Table 30/30
#

# SKC
:SKC is opcode=0x61; opcode=0xC8 {
    inst_sk(CY);
}

# SKNC
:SKNC is opcode=0x61; opcode=0xD8 {
    inst_sk(!CY);
}

# SKZ
:SKZ is opcode=0x61; opcode=0xE8 {
    inst_sk(Z);
}

# SKNZ
:SKNZ is opcode=0x61; opcode=0xF8 {
    inst_sk(!Z);
}

# SKH
:SKH is opcode=0x61; opcode=0xE3 {
    inst_sk(!(Z | CY));
}

# SKNH
:SKNH is opcode=0x61; opcode=0xF3 {
    inst_sk(Z | CY);
}

# SEL RBn
:SEL rbs_op_n is opcode=0x61; op_l=0xF & rbs_op_n & mov1_sreg=1 {
    # Update all RBS registers to make sure only one
    # is active at a time.
    RBS0 = (rbs_op_n == 0);
    RBS1 = (rbs_op_n == 1);
    RBS2 = (rbs_op_n == 2);
    RBS3 = (rbs_op_n == 3);
}

# NOP
:NOP is opcode=0x00 {}

# EI
:EI is opcode=0x71; opcode=0x7A; opcode=0xFA {
    PSW = PSW | (1 << 7);
    update_psw(PSW);
    enable_interrupts();
}

# DI
:DI is opcode=0x71; opcode=0x7B; opcode=0xFA {
    PSW = PSW & (0 << 7);
    update_psw(PSW);
    disable_interrupts();
}

# HALT
:HALT is opcode=0x61; opcode=0xED { halt(); }

# STOP
:STOP is opcode=0x61; opcode=0xFD { stop(); }

# PREFIX
: is opcode=0x11 [ es_prefix=1; globalset(inst_next, es_prefix); ] {}
